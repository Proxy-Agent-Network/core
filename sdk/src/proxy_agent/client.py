import requests
import json
import base64
import os
from typing import Dict, Any, Optional
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import padding, rsa

# PROXY PROTOCOL - PYTHON SDK CLIENT v1.7
# "Bridging the gap with sub-second cryptographic settlement."
# ----------------------------------------------------

class ProxyClient:
    """
    The official Python client for the Proxy Agent Network.
    
    v1.7 Update:
    - Integrated LND REST API support for HODL invoice payments.
    - End-to-end encryption utilities for biological and legal proofs.
    - Updated for src-layout compatibility.
    """
    
    def __init__(self, api_key: str, base_url: str = "https://api.proxyprotocol.com/v1"):
        self.api_key = api_key
        self.base_url = base_url
        self.session = requests.Session()
        self.session.headers.update({
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json",
            "User-Agent": "ProxyAgent-Python/1.7.0"
        })
        
        # Local LND Credentials for funding tasks
        # These are used to pay BOLT11 invoices generated by the Proxy API
        self.lnd_host = os.getenv("LND_REST_HOST", "127.0.0.1:8080")
        self.lnd_macaroon = os.getenv("LND_ADMIN_MACAROON_HEX", "")
        self.lnd_cert_path = os.getenv("LND_TLS_CERT_PATH", "") # Optional path to tls.cert

    # --- 1. Identity & Encryption Utilities ---

    def generate_agent_keys(self) -> Dict[str, str]:
        """
        Generates a new RSA-2048 key pair for the Agent.
        The public key should be passed to create_task() to enable the 
        Encrypted Task Tunnel (v1.1+).
        """
        private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048
        )
        
        pem_private = private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption()
        ).decode('utf-8')

        pem_public = private_key.public_key().public_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PublicFormat.SubjectPublicKeyInfo
        ).decode('utf-8')

        return {
            "private_key": pem_private,
            "public_key": pem_public
        }

    def decrypt_result(self, encrypted_blob: str, private_key_pem: str) -> Dict[str, Any]:
        """
        Decrypts the task result blob using the Agent's private key.
        Matches the RSA-OAEP / SHA-256 standard used by the Node Daemon.
        """
        try:
            private_key = serialization.load_pem_private_key(
                private_key_pem.encode('utf-8'),
                password=None
            )

            ciphertext = base64.b64decode(encrypted_blob)

            plaintext = private_key.decrypt(
                ciphertext,
                padding.OAEP(
                    mgf=padding.MGF1(algorithm=hashes.SHA256()),
                    algorithm=hashes.SHA256(),
                    label=None
                )
            )

            return json.loads(plaintext.decode('utf-8'))
        except Exception as e:
            raise ValueError(f"Decryption failed: {str(e)}. Verify the private key matches the task's public key.")

    # --- 2. Settlement Layer: LND Payment Integration ---

    def fund_task_via_lnd(self, bolt11: str) -> Dict[str, Any]:
        """
        v1.7: Communicates with the Agent's local LND node to pay the HODL invoice.
        This locks the funds in the Lightning circuit, signaling the Human Node to start work.
        """
        url = f"https://{self.lnd_host}/v1/channels/transactions"
        headers = {"Grpc-Metadata-macaroon": self.lnd_macaroon}
        
        payload = {
            "payment_request": bolt11,
            "timeout_seconds": 60,
            "fee_limit_sat": 1000
        }
        
        # Handle TLS verification for local LND
        verify = self.lnd_cert_path if self.lnd_cert_path else False
        
        print(f"[*] Dispatching Lightning Payment via LND...")
        response = requests.post(url, json=payload, headers=headers, verify=verify)
        
        if response.status_code != 200:
            raise RuntimeError(f"LND Payment Failed: {response.text}")
            
        return response.json()

    # --- 3. Core API Endpoints ---

    def get_market_ticker(self) -> Dict[str, Any]:
        """Fetch real-time floor prices for human tasks in Satoshis."""
        response = self.session.get(f"{self.base_url}/market/ticker")
        response.raise_for_status()
        return response.json()

    def create_task(self, task_type: str, requirements: Dict[str, Any], max_budget_sats: int, public_key: Optional[str] = None) -> Dict[str, Any]:
        """
        Broadcasts a new task to the network.
        
        Args:
            task_type: 'verify_sms_otp', 'legal_notary_sign', etc.
            requirements: Metadata for the physical execution.
            max_budget_sats: Bid amount.
            public_key: Optional RSA public key to enable end-to-end encryption.
        """
        payload = {
            "type": task_type,
            "requirements": requirements,
            "max_budget_sats": max_budget_sats
        }
        
        if public_key:
            payload['agent_public_key'] = public_key

        response = self.session.post(f"{self.base_url}/tasks", json=payload)
        response.raise_for_status()
        return response.json()

    def get_task_status(self, task_id: str) -> Dict[str, Any]:
        """Poll the network for the status or final result of a task."""
        response = self.session.get(f"{self.base_url}/tasks/{task_id}")
        response.raise_for_status()
        return response.json()
